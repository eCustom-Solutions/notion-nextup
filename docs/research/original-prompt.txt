
# üëã Cursor
We need Notion-API support inside the `notion-nextup/` TypeScript project.
Do **not** touch `core.ts`; just supply data to it and write results back.

## 1. New module: src/notionAdapter.ts
Export:
  ‚Ä¢ `loadTasks(databaseId: string): Promise<Task[]>`
      - Query the given DB with the throttled client in `services/notion_client.ts`
      - For each page, map its properties into the `Task` interface:
          Name                       ‚Üê title
          Task Owner                 ‚Üê ‚ÄúTask Owner‚Äù people prop (first person name)
          Status (IT)                ‚Üê status/select prop
          Estimated Days             ‚Üê number prop
          Estimated Days Remaining   ‚Üê number prop (fallback to Estimated Days)
          Due                        ‚Üê date prop (Month DD, YYYY string)
          Priority                   ‚Üê select prop (‚ÄúHigh/Medium/Low‚Äù or empty)
          Parent Task (optional)     ‚Üê relation or text field
      - Skip pages where Status is one of the EXCLUDED_STATUSES
  ‚Ä¢ `writeBack(tasks: ProcessedTask[], databaseId: string): Promise<void>`
      - For each task received from `calculateQueueRank`:
          ¬∑ find the Notion page by `id` (add `pageId` onto Task during load)
          ¬∑ update properties:
              queue_rank                     ‚Üí number
              Projected Days to Completion   ‚Üí number
              Estimated Days Remaining       ‚Üí number (sync with Estimated Days)
      - Batch updates: 3 rps max (use existing client throttling)

## 2. Update CLI (src/notionNextup.ts)
  ‚Ä¢ Add flags:
       --notion-db <DB_ID>      (pull + push mode)
       --dry-run                (skip writeBack, just log)
  ‚Ä¢ If --notion-db is set:
       1. await loadTasks()
       2. run calculateQueueRank()
       3. unless --dry-run, await writeBack()

## 3. Optional webhook (skip unless you have time)
  ‚Ä¢ `src/webhook.ts` ‚Äì simple Express POST `/notion-webhook`
  ‚Ä¢ On hit, call the same runner (debounce 30 sec).

## 4. ENV
  ‚Ä¢ Expect NOTION_API_KEY already loaded by services/notion_client.ts
  ‚Ä¢ Pass DB ID via CLI flag or env var.

## 5. Testing stub
  ‚Ä¢ `npm run dev:notion -- --notion-db $DB_ID --dry-run`
    ‚Üí should log ‚ÄúProcessed N tasks‚Äù with projected dates.

Keep it isolated; no refactors beyond what‚Äôs specified.

## 6.  Notion API shape & helper details  üöß  (append to previous prompt)

### 6-A. How to READ pages
Use the throttled client that already lives at `services/notion_client.ts`:

```ts
import notion from '../services/notion_client';

export async function loadTasks(databaseId: string): Promise<Task[]> {
  const tasks: Task[] = [];
  let cursor: string | undefined = undefined;

  do {
    const res = await notion.databases.query({
      database_id: databaseId,
      page_size: 100,
      start_cursor: cursor,
    });
    for (const page of res.results) {
      // ‚Üì‚Üì‚Üì  extract properties here  ‚Üì‚Üì‚Üì
      const props = page.properties;
      const title = props['Name']?.title?.[0]?.plain_text ?? '';
      const ownerPeople = props['Task Owner']?.people ?? [];
      const owner = ownerPeople[0]?.name ?? '';
      const status = props['Status (IT)']?.status?.name ?? '';
      const estDays = props['Estimated Days']?.number ?? 0;
      const estRem  = props['Estimated Days Remaining']?.number ?? estDays;
      const dueDate = props['Due']?.date?.start
        ? new Date(props['Due'].date.start).toLocaleDateString('en-US', { month:'long', day:'numeric', year:'numeric' })
        : undefined;
      const priority = props['Priority']?.select?.name ?? '';

      tasks.push({
        pageId: page.id,                 // <--  augment Task type locally
        Name: title,
        'Task Owner': owner,
        'Status (IT)': status,
        'Estimated Days': estDays,
        'Estimated Days Remaining': estRem,
        'Due': dueDate,
        'Priority': priority,
        'Parent Task': props['Parent Task']?.relation?.[0]?.id // or blank
      } as Task);
    }
    cursor = res.has_more ? res.next_cursor : undefined;
  } while (cursor);

  return tasks;
}


6-B. How to WRITE updates back

Only three properties are mutated:

Key in Notion   Type    Value we write
queue_rank  number  task.queue_rank
Projected Days to Completion    number  task[‚ÄòProjected Days to Completion‚Äô]
Estimated Days Remaining    number  task[‚ÄòEstimated Days Remaining‚Äô]


export async function writeBack(tasks: ProcessedTask[], dbId: string) {
  for (const t of tasks) {
    await notion.pages.update({
      page_id: t.pageId,             // came from loadTasks
      properties: {
        'queue_rank': {
          number: t.queue_rank
        },
        'Projected Days to Completion': {
          number: t['Projected Days to Completion']
        },
        'Estimated Days Remaining': {
          number: t['Estimated Days Remaining']
        }
      }
    });
  }
}


Neo-pattern: keep the pageId on the in-memory object; do not look it up twice.




6-C. Property-type cheat sheet

Notion Property Type    JSON shape you must send on update

number  { number: 42 }
select  { select: { name: "High" } }
status  { status: { name: "In Progress" } }
date    { date: { start: "2025-08-05" } }
people  { people: [{ id: "user-id" }] }
relation    { relation: [{ id: "page-id" }] }


6-D. Rate limit reminder

The proxy-wrapped client already enforces 3 req/s, 1 concurrent (see services/notion_client.ts).
If you batch-update 300 tasks that‚Äôs ~100 s ‚Äì fine for the demo.

6-E. Env vars
	‚Ä¢	NOTION_API_KEY ‚Äì already consumed by the proxy client
	‚Ä¢	NOTION_DB_ID   ‚Äì pass via --notion-db CLI flag; fallback to process.env.NOTION_DB_ID

6-F. Task interface patch

Inside src/types.ts add:

export interface Task { ‚Ä¶; pageId?: string; }
export interface ProcessedTask extends Task { pageId: string; ‚Ä¶ }

(no breaking changes because CSV flow never sets pageId).

With this context Cursor has the exact request/response shapes it needs.